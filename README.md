Софтверско инженерство – Лабораториска вежба 2

Име и презиме: Александар Крстески

Број на индекс: 186002

Група на код: 6

Control Flow Graph за проблемот:

![](https://github.com/Alkrekstsaesndkiar/SI_lab2_186002/blob/master/ControlFlowGraph.png)

Цикломатската комплексност на функцијата е 7. Тоа се добива согласно формулата P+1, каде P е бројот на предикатни јазли во рамки на функцијата. Во случајов, бројот на предикатни јазли е 6, еден за тестирање на условот за влез во for циклусот, друг за тестирање на условот if(deg\&gt;=0 &amp;&amp; deg\&lt;360), трет за тестирање на условот if(min\&lt;0 || min\&gt;59), четврт за тестирање на условот if(sec\&lt;0 || sec\&gt;59), петти за тестирање на условот if(deg==360) и шести за тестирање на условот if(min==0 &amp;&amp; sec==0).

Одговор на прашање број 3:

Табеларен приказ на сите statements кои се извршуваат при даден тест случај:

![](https://github.com/Alkrekstsaesndkiar/SI_lab2_186002/blob/master/TableStatements.png)

За every statement критериумот во овој случај, земаме 6 различни влезови, при што во секој од случаите се работи за влез кој се состои од само еден агол, односно листата со големини на агли би содржела само еден елемент, а со тоа и for циклусот ќе има само една итерација. Можеме и да го намалиме бројот на влезови, со тоа што во секој од влезовите ќе ставаме по повеќе агли, и притоа изминатите statements при извршувањето на функцијата би биле &quot;комбинација&quot; од изминатите statements при извршување на функцијата за секој од влезовите одделно, со таа разлика што во случај кога имаме повеќе агли во листата, не секогаш ова важи, затоа што ако за првиот агол се изминуваат едни statements, а за вториот се изминуваат плус некои други, доколку кај првиот агол дојде до фрлање на исклучок, ќе се излезе од for циклусот (односно ќе прекине програмата со извршување), а поради што нема да се изминат оние statements кои би се изминале за вториот агол, а не се изминале за првиот агол. Значи, кога ставаме повеќе агли во листата, битен е распоредот на елементите во неа. Не е исто дали два агли x и y ќе бидат ставени во листата така што во еден случај x ќе се наоѓа на позиција 0 и y на позиција 1, или пак обратно, y да се наоѓа на позиција 0, а x на позиција 1.

Накратко да опишеме што е опфатено со секој statement:

A – иницијализирање на листата result и иницијализирање на бројачот за for циклусот

B – тестирање на условот во рамки на for циклусот

C – декларирање и иницијализирање на локални променливи во рамки на for циклусот во кои при секоја итерација ќе се зачувуваат вредностите на бројот на степени, минути и секунди на аголот кој тековно се изминува од листата

D – тестирање на условот if(deg\&gt;=0 &amp;&amp; deg\&lt;360)

E – тестирање на условот if(min\&lt;0 || min\&gt;59)

F – фрлање исклучокод тип RuntimeException со порака &quot;The minutes of the angle are not valid!&quot;

G – тестирање на условот if(sec\&lt;0 || sec\&gt;59)

H - фрлање исклучокод тип RuntimeException со порака &quot;The seconds of the angle are not valid!&quot;

I – додавање на големината на тековниот агол претворена во секунди во листата result во случај кога се работи за агол кој не е максимално голем

J – тестирање на условот if(deg==360)

K – тестирање на условот if(min==0 &amp;&amp; sec==0)

L - додавање на големината на тековниот агол претворена во секунди во листата result во случај кога се работи за агол кој е максимално голем

M - фрлање исклучокод тип RuntimeException со порака &quot;Theangle is greater than the maximum&quot;

N - фрлање исклучокод тип RuntimeException со порака &quot;The angle is smaller or greater than the minimum&quot;

O – инкрементирање на бројачот за циклусот

P – враќање на листата result која ги содржи големините на секој од аглите дадени на влез претворени во секунди, како излез кој се очекува од функцијата

Првите четири влезови се со цел да се изминат сите statements каде се фрла исклучок, првиот влез за исклучокот поврзан со несоодветен број на минути, вториот за исклучокот поврзан со несоодветен број на секунди, третиот за исклучокот фрлен поради агол кој е поголем од максималниот, а четвртиот за исклучокот фрлен поради број на степени кој е помал од 0, или пак поголем од 360.

При првиот влез, имаме невалиден број на минути. Затоа, јасно е дека се извршуваат сите statements од A до F, односно се иницијализира листата result, а исто така и бројачот на for циклусот, потоа се проверува условот во рамки на циклусот, кој што е исполнет на почетокот, па се иницијализираат променливите deg, min и sec, после што се тестира условот во рамки на statement D, кој поминува, затоа што бројот на степени е помеѓу 0 и 360, за на крај да се дојде до условот во рамки на statement Е, каде поради невалидниот број на минути исто така ќе помине, и како резултат на тоа ќе се изврши и statement F, а поради што ќе се фрли исклучок за невалиден број на минути и програмата ќе заврши со работа.

При вториот влез ситуацијата е слична. Сега се извршуваат сите statements од A до E, но сега бројот на минути е валиден, па затоа не поминува условот кој се тестира во рамки на statement E, поради што се скока на else делот, каде потоа се тестира условот во рамки на statement G, кој поради невалидниот број на секунди ќе помине, при што се доаѓа до statement H, кој што се извршува и како резултат на тоа фрла исклучок за невалиден број на секунди, со што програмата ќе заврши со работа.

При третиот влез, бројот на степени за дадениот агол е 360. Тоа значи дека ќе се извршат сите statements од A до D, и тестирањето на условот во рамки на statement D нема да помине, бидејќи бројот на степени за тековниот агол не е помеѓу 0 и 360, туку точно 360. Поради тоа, се скока на делот else каде се тестира условот во рамки на statement J, кој ќе помине. Потоа се тестира условот во рамки на statement K, кој бидејќи бројот на минути и секунди не е еднаков на 0, нема да помине, а тоа ќе резултира со скокање кај else делот каде се наоѓа кодот од statement M, кој што ќе се изврши и ќе фрли исклучок за агол кој е поголем од максималниот, при што програмата завршува со работа.

При четвртиот влез, бројот на степени е -2 и тоа е невалидно. Затоа, слично како при третиот влез, ќе се извршат сите statements од A до D, при што кога ќе се тестира условот во рамки на statement D, тој нема да помине. Поради тоа, се скока на делот од кодот каде се тестира условот во рамки на statement J, кој што исто така нема да помине, за на крај да се скокне до else делот, каде што се наоѓа кодот од statement N, кој кога ќе се изврши ќе фрли исклучок за агол кој е помал, или пак поголем од минималниот можен агол, а со тоа програмата ќе заврши со работа.

Сега, откако сме ги спровеле сите овие четири тестови, со кои се извршува делот од кодот наменет за справување со несоодветна големина на агол, останува уште да се изминат оние statements во кои се калкулира големината на валиден агол во секунди и се додава во листата result, која пак на крајот од циклусот, поради нормален излез, ќе се врати како резултат од функцијата.

Валидниот агол може да биде агол чија големина е помеѓу 0 и 360 степени, помеѓу 0 и 59 минути и помеѓу 0 и 59 секунди, или пак агол кој е максимално голем, односно агол од 360 степени, 0 минути и 0 секунди. Односно, имаме валиден агол кој не е максимално голем и валиден агол кој е максимално голем.

За да го изминеме делот од кодот кој ги врши калкулациите за големината на овие два типа на валидни агли во секунди, и кој резултатот од пресметката го запишува во листата result, која на крајот се враќа како резултат на функцијата, додаваме уште два влезови, еден влез со валиден но не максимално голем агол, и друг влез со максимално голем агол.

При петтиот влез, кога имаме валиден агол кој не е максимално голем, бројот на степени е помеѓу 0 и 360, така што ќе се извршат сите statements од A до D, при што кога ќе се тестира условот во рамки на statement D, тој ќе помине и ќе се пристапи кон тестирање на условот во рамки на statement E. Овде, тестирањето нема да помине, затоа што бројот на минути е валиден. Поради тоа, се скока на делот else, каде се тестира условот во рамки на statement G, кој исто така, бидејќи бројот на секунди е валиден, нема да помине, и повторно ќе се скокне на else делот. Во овој момент, веќе е јасно дека се работи за валиден агол, и поради тоа се доаѓа до statement I, каде што се врши калкулацијата на големината на тој агол во секунди и нејзино додавање во листата result. Со ова завршува првата итерација на циклусот, и следи извршувањето на statement O, при што се инкрементира бројачот за циклусот, и се оди на повторна проверка на условот за влез во циклусот, но бидејќи листата од агли која сме ја задале на влез на функцијата има само еден елемент, кога ќе се инкрементира бројачот на 1, условот за влез во for циклусот веќе не е исполнет и се излегува од циклусот. По излегувањето од циклусот, се извршува statement P, при што листата result се враќа како резултат од функцијата.

На крај, при шестиот влез, имаме валиден агол кој е максимално голем. Повторно се извршуваат сите statements од A до D, каде сега поради тоа што бројот на степени е 360, нема да помине тестирањето на условот во рамки на statement D, поради што се скока на делот каде се тестира условот во рамки на statement J. Овде, тестирањето поминува, и се преминува на тестирање на условот во рамки на statement K, кое исто така поминува, бидејќи бројот на минути и секунди е 0. После ова се извршува statement L, каде се врши калкулацијата на големината на аголот во секунди и истата се става во листата result. Откако ќе заврши ова, завршува првата итерација на for циклусот, и се преминува на извршување на statement O, каде се инкрементира бројачот на циклусот и од истите причини како и при петтиот влез, се излегува од for циклусот. По излегувањето од for циклусот, се преминува на извршување на statement P, при што листата result се враќа како резултат од функцијата.

На овој начин, со извршување на сите овие тест случаи, се овозможува извршување на секој statement барем еднаш, што е и целта која треба да се постигне при испишување на тест случаи, а со цел да се задоволи every statement критериумот.

Одговор на прашање број 4:

Табеларен приказ на сите ребра кои се изминуваат при даден тест случај:

![](https://github.com/Alkrekstsaesndkiar/SI_lab2_186002/blob/master/TableBranches.png)

Слободно можеме да ги искористиме истите влезови што ги користевме кај every statement критериумот, бидејќи со овие влезови не само што се изминуваат сите statements, соодветно дефинирани во описот за исполнување на every statement критериумот, туку исто така се изминуваат и сите branches кои ги поврзуваат јазлите во control flow графот.

Најпрво, да опишеме што се случува во кодот опфатен во рамки на секој од јазлитекои се наоѓаат во control flow графот:

A – се иницијализира листата result и се иницијализира бројачот за for циклусот

B – се тестира условот за влез во циклусот

C – се иницијализираат променливите deg, min и sec, во кои се чуваат степените, минутите и секундите на тековниот агол, соодветно. Исто така и се тестира условот if(deg\&gt;=0 &amp;&amp; deg\&lt;360)

D – се тестира условот if(min \&lt;0 || min\&gt;59)

E – се фрла исклучок од типот RuntimeException со порака &quot;The minutes of the angle are not valid!&quot;

F – се тестира условот if(sec\&lt;0 || sec\&gt;59)

G - се фрла исклучок од типот RuntimeException со порака &quot;The seconds of the angle are not valid!&quot;

H – се врши пресметката на големината на аголот во секунди, во случај кога се работи за валиден агол кој не е максимално голем, и добиената вредност се додава во листата result

I – се тестира условот if(deg==360)

J – се тестира условот if(min==0 &amp;&amp; sec==0)

K - се врши пресметката на големината на аголот во секунди, во случај кога се работи за валиден агол кој е максимално голем, и добиената вредност се додава во листата result

L - се фрла исклучок од типот RuntimeException со порака &quot;The angle is greater than the maximum&quot;

M - се фрла исклучок од типот RuntimeException со порака &quot;The angle is smaller or greater than the minimum&quot;

N – се инкрементира бројачот за циклусот

O – се враќа листата result како резултат од функцијата

P – програмата завршува со работа

Ги користиме истите влезови во тестовите за every branch критериумот како и за every statement критериумот. Во рамки на објаснението за текот на извршувањето на програмата (односно функцијата) за секој од влезовите, испишано за опис на тестовите со кои се задоволува every statement критериумот, за влезовите ги изведуваме следните заклучоци:

За првиот влез ќе се изврши кодот од сите јазли долж патеката A,B,C,D,E,P, односно ќе се изминат ребрата A-B,B-C,C-D,D-E и E-P.

Слично, за вториот влез ќе се изврши кодот од сите јазли долж патеката A, B, C, D, F, G, P, односно ќе се изминат ребрата A-B, B-C, C-D, D-F, F-G и G-P.

Понатаму, за третиот влез ќе се изврши кодот од сите јазли долж патеката A, B, C, I, J, L, P, односно ќе се изминат ребрата A-B, B-C, C-I, I-J, J-L и L-P.

За четвртиот влез ќе се изврши кодот од сите јазли долж патеката A, B, C, I, M, P, односно ќе се изминат ребрата A-B, B-C, C-I, I-M и M-P.

За петтиот влез ќе се изврши кодот од сите јазли долж патеката A, B, C, D, F, H, N, B, O, односно ќе се изминат ребрата A-B, B-C, C-D, D-F, F-H, H-N, N-B и B-O.

И на крајот, за шестиот влез ќе се изврши кодот од сите јазли долж патеката A, B, C, I, J, K, N, B, O, односно ќе се изминат ребрата A-B, B-C, C-I, I-J, J-K, K-N, N-B и B-O.

Така, со извршување на сите овие тест случаи, се овозможува секое ребро (branch) да се измине барем еднаш, што е и целта која треба да се постигне при испишување на тест случаи со помош на кои треба да се задоволи every branch критериумот.

JUnit тестовите за двата критериуми се идентични, затоа што со истите тестови кои го задоволуваат every statement критериумот, се задоволува и every branch критериумот.

На почеток на секоја од функциите за тестирање на двата критериуми, кои се наполно идентични помеѓу себе, инстанцираме еден RuntimeException објект, во кој ќе ги чуваме резултатите од assertThrows() функцијата. Оваа функција тестира дали функцијата која ни е од интерес фрла исклучок од специфичен тип, во случајов од тип RuntimeException, и притоа, доколку тестот помине, односно функцијата која ни е од интерес фрла исклучок од таков тип, функцијата assertThrows() го враќа тој исклучок како резултат. Токму затоа го декларираме објектот од тип RuntimeException на почетокот на функцијата за тестирање, за да можеме потоа во него да го сочуваме исклучокот кој ќе го врати функцијата assertThrows(). Освен RuntimeException објектот, декларираме и една листа од агли и ја иницијализираме на празна листа.

За секој тест случај кој фрла исклучок, односно за секој различен влез со кој се тестира како се однесува функцијата кога доаѓа до фрлање на исклучок, кодот за тестирање на исправноста на функцијата е потполно идентичен за секој од тие тест случаи. За секој од нив се инстанцира објект од класата Angle, односно креираме агол, задавајќи ги соодветните вредности за степени, минути и секунди на аголот кој го користиме во тој тест случај. Потоа го додаваме тој агол во листата на агли со која планираме да ја повикаме функцијата која ни е од интерес да ја истестираме, бидејќи таа функција прима листа од агли на влез. Потоа ја повикуваме функцијата assertThrows() за да провериме дали функцијата која ни е од интерес, повикана со влезен параметар листата од агли во која сме го додале аголот претходно, фрла исклучок од тип RuntimeException. Ако работи правилно, функцијата треба да фрли исклучок со соодветна порака. Овој исклучок го зачувуваме во RuntimeException објектот кој што го инстанциравме претходно за оваа намена. После ова, проверувамедали е фрлен исклучок со соодветна порака или не. За тоа ја користиме функцијата assertTrue(), со која проверуваме дали е точно дека пораката која се состои во исклучокот кој го фрлила функцијата е точно онаа порака која треба да се наоѓа во соодветниот исклучок. Со други зборови, проверуваме дали се фрлил вистинскиот исклучок кој ние очекуваме дека функцијата ќе го фрли. На крајот, ја празниме листата со агли, за да можеме за следниот тест случај при кој се фрла исклучок да инстанцираме нов објект од класата Angle, односно да креираме нов агол, кому му ги задаваме вредностите за број на степени, минути и секунди соодветни на аголот со кој тестираме во следниот тест случај. Понатаму, постапката е идентична за секој од тест случаите кои фрлаат исклучоци.

Постапката за проверка на функцијата при користење на тест случаи кои не предизвикуваат фрлање исклучок е малку поразлична. Но сепак, за секој од таквите тест случаи, постапката е иста. Се состои во тоа што на почетокот инстанцираме објект од класата Angle, односно креираме агол со вредности за степени, минути и секунди соодветни на аголот кој го користиме во тој тест случај. Потоа, го додаваме тој агол во листата на агли која ја предаваме како аргумент при повик на функцијата. После ова ја повикуваме функцијата assertEquals(), со која ќе провериме дали функцијата правилно ја калкулира големината на аголот во секунди, односно, ќе провериме дали вредноста која се содржи во рамки на листата која ја враќа функцијата како резултат, е точно големината во секунди на соодветниот агол за кој функцијата пресметувала. И повторно, на крајот, ја празниме листата со агли, за да можеме да ја повикаме функцијата при следниот тест случај со листа која ќе го содржи аголот кој се користи при тој тест случај, кој претходно бил инстанциран како објект од класата Angle со соодветни вредности за степени, минути и секунди кои одговараат на оние на аголот кој се користи во тој тест случај, и откако сме го инстанцирале, го додаваме во листата со агли за да можеме да ја повикаме функцијата со таа листа и повторно да ја искористиме функцијата assertEquals() за да ја провериме нејзината функционалност. Оваа постапка важи за сите тест случаи при кои функцијата не фрла исклучок.
